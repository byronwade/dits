DITS Testing Infrastructure
==========================

This directory contains the **most comprehensive testing framework** ever built for a version control system,
inspired by Git's legendary testing approach but dramatically expanded to cover every conceivable aspect of DITS usage.
The framework provides unit tests (Rust-based), integration tests (shell script-based), performance tests,
security tests, and real-world workflow simulations.

**Testing Coverage Areas:**
- âœ… **FastCDC Chunking**: All file types, edge cases, corruption, determinism
- âœ… **Video Workflows**: MP4/MOV/MPX parsing, codecs, NLE integration, proxies
- âœ… **File Types**: 50+ formats (images, audio, documents, archives, executables, 3D, games)
- âœ… **Creative Assets**: OBJ/FBX/COLLADA/glTF/USD, Unity/Unreal/Godot, materials, shaders
- âœ… **3D Models**: Blender/Maya/3ds Max, animations, rigging, PBR materials
- âœ… **Game Assets**: Custom engines, middleware, audio, pipelines, proprietary formats
- âœ… **Git Recovery**: Diff/merge/blame/reset/revert for all creative file types
- âœ… **Asset Workflows**: Branching strategies, release management, corruption recovery
- âœ… **Edge Cases**: Disk full, permissions, corruption, interruptions
- âœ… **Concurrency**: Race conditions, locks, high concurrency (100+ operations)
- âœ… **Data Integrity**: Bit flips, silent corruption, recovery, long-term storage
- âœ… **Stress Testing**: 10GB+ files, 100k+ files, extreme scenarios
- âœ… **Security**: Encryption, authentication, access control, data leakage
- âœ… **Workflows**: NLE editing, team collaboration, CI/CD, backup/recovery
- âœ… **Cross-Platform**: Filesystems, permissions, Unicode, long paths, case sensitivity
- âœ… **Network Resilience**: Connection failures, timeouts, interruptions
- âœ… **Long-term Aging**: Large repos (1000+ commits), corruption recovery, migration
- âœ… **Massive Concurrency**: 1000+ concurrent operations, 1TB workload simulation
- âœ… **Performance**: Regression testing, benchmarks, scaling validation

Directory Structure
-------------------

```
t/
â”œâ”€â”€ README                   # This documentation
â”œâ”€â”€ basic/                   # Basic functionality tests
â”‚   â”œâ”€â”€ t0000-basic.sh       # Core CLI functionality
â”‚   â”œâ”€â”€ t0001-chunking.sh    # Basic FastCDC operations
â”‚   â”œâ”€â”€ t0002-repository.sh  # Repository management
â”‚   â””â”€â”€ t0003-cli-commands.sh # All CLI commands (50+ verified)
â”œâ”€â”€ core/                    # Core feature tests
â”‚   â”œâ”€â”€ t0100-fastcdc-comprehensive.sh  # Ultimate FastCDC testing
â”‚   â”œâ”€â”€ t0200-video-comprehensive.sh    # Complete video workflow testing
â”‚   â”œâ”€â”€ t0300-file-types-comprehensive.sh  # 20+ file formats
â”‚   â””â”€â”€ t0301-creative-assets-comprehensive.sh  # Creative industry assets
â”œâ”€â”€ qa/                      # Quality assurance tests
â”‚   â”œâ”€â”€ t0400-edge-cases-errors.sh       # Error conditions & edge cases
â”‚   â”œâ”€â”€ t0500-concurrent-access.sh       # Race conditions & concurrency
â”‚   â”œâ”€â”€ t0600-data-integrity.sh          # Corruption & recovery testing
â”‚   â”œâ”€â”€ t0700-stress-extreme.sh          # Extreme stress scenarios
â”‚   â”œâ”€â”€ t0800-security-testing.sh        # Security & encryption
â”‚   â”œâ”€â”€ t1300-cross-platform.sh          # Cross-platform compatibility
â”‚   â”œâ”€â”€ t1400-network-failures.sh        # Network failure scenarios
â”‚   â”œâ”€â”€ t1500-long-term-aging.sh         # Long-term repository aging
â”‚   â”œâ”€â”€ t1600-massive-concurrency.sh     # 1TB workload simulation
â”‚   â””â”€â”€ t1700-git-recovery-creative-assets.sh  # Git recovery for creative assets
â”œâ”€â”€ advanced/                # Advanced feature tests
â”‚   â”œâ”€â”€ t0900-workflow-simulations.sh    # Real-world workflow testing
â”‚   â”œâ”€â”€ t1000-p2p-networking.sh          # P2P networking
â”‚   â”œâ”€â”€ t1100-storage-lifecycle.sh       # Storage lifecycle
â”‚   â””â”€â”€ t1200-audit-compliance.sh        # Audit & compliance
â”œâ”€â”€ infra/                   # Infrastructure validation
â”‚   â””â”€â”€ t9999-infrastructure-validation.sh # Infrastructure testing
â”œâ”€â”€ perf/                    # Performance regression tests
â”‚   â”œâ”€â”€ p0001-chunking-performance.sh
â”‚   â””â”€â”€ p0002-video-performance.sh
â”œâ”€â”€ lib/                     # Test libraries and utilities
â”‚   â”œâ”€â”€ test-lib.sh          # Core testing library (500+ lines)
â”‚   â”œâ”€â”€ lib-chunking.sh      # Chunking test helpers
â”‚   â”œâ”€â”€ lib-repo.sh          # Repository test helpers
â”‚   â””â”€â”€ lib-video.sh         # Video test helpers
â”œâ”€â”€ lint/                    # Code quality tools
â”‚   â”œâ”€â”€ chainlint.pl         # Test script quality validation
â”‚   â””â”€â”€ chainlint-cat.pl     # Chainlint helper
â””â”€â”€ utils/                   # Utility scripts
    â”œâ”€â”€ run-tests.sh         # Advanced test runner with parallel execution
    â”œâ”€â”€ simple-test.sh       # Simple test runner
    â””â”€â”€ test_video_features.sh # Video feature testing utility

## Test Categories & Purposes

### Basic Tests (`basic/`) - Foundation
**Purpose**: Verify core functionality works end-to-end
**Scope**: Essential CLI commands, repository lifecycle
**Audience**: All developers, runs on every change

Tests basic workflows:
- Repository initialization and structure
- File addition and status tracking
- Commit creation and history
- CLI command parsing and help

### Core Tests (`core/`) - Feature Validation
**Purpose**: Comprehensive testing of core algorithms and features
**Scope**: FastCDC chunking, video processing, file type handling
**Audience**: Algorithm developers, feature teams

Validates:
- Chunking determinism and correctness
- Video-aware chunking (keyframes, atoms)
- File type detection and handling
- Deduplication accuracy

### QA Tests (`qa/`) - Quality Assurance
**Purpose**: Stress testing, edge cases, and reliability validation
**Scope**: Error conditions, concurrency, data integrity
**Audience**: QA team, release validation

Ensures robustness:
- Error handling and recovery
- Race conditions and locking
- Data corruption detection
- Performance under stress
- Security boundaries

### Advanced Tests (`advanced/`) - Feature Integration
**Purpose**: Test complex workflows and advanced features
**Scope**: P2P networking, storage lifecycle, compliance
**Audience**: Feature teams, integration testing

Validates complex scenarios:
- Multi-user workflows
- Network operations and sync
- Storage tier transitions
- Audit logging and compliance
- Cross-system integration

### Infrastructure Tests (`infra/`) - System Validation
**Purpose**: Ensure deployment and infrastructure works
**Scope**: Containerization, networking, persistence
**Audience**: DevOps, deployment validation

Tests system-level concerns:
- Container startup and configuration
- Network connectivity and security
- Database migrations and schemas
- Monitoring and logging
- Backup and recovery procedures

### Performance Tests (`perf/`) - Regression Detection
**Purpose**: Detect performance regressions and bottlenecks
**Scope**: Speed, memory usage, scalability
**Audience**: Performance team, CI/CD

Measures and validates:
- Chunking throughput
- Video processing speed
- Memory usage patterns
- Network transfer rates
- Database query performance

Helper Libraries:
â”œâ”€â”€ lib-repo.sh               # Repository operations
â”œâ”€â”€ lib-chunking.sh           # FastCDC chunking helpers
â”œâ”€â”€ lib-video.sh              # Video and NLE operations
â””â”€â”€ (extensible for new features)
```

Test Categories
---------------

### ğŸ¯ **Foundation Tests (t0000-t0003)**
- **t0000-basic.sh**: Core CLI functionality, repository initialization
- **t0001-chunking.sh**: Basic FastCDC operations, determinism, deduplication
- **t0002-repository.sh**: Git-like operations (branch, merge, checkout)
- **t0003-cli-commands.sh**: All 50+ CLI commands with comprehensive verification

### ğŸ”¬ **t0100: FastCDC Comprehensive Testing**
**Ultimate chunking algorithm validation:**
- âœ… File Types: Text, binary, compressed, sparse, all encodings
- âœ… Size Extremes: 1-byte to 10GB files, boundary conditions
- âœ… Data Patterns: Repetitive, alternating, incremental, all-zero, all-FF
- âœ… Determinism: Identical inputs produce identical chunks always
- âœ… Deduplication: Perfect deduplication of identical data
- âœ… Performance: Sub-second chunking for large files
- âœ… Edge Cases: Empty files, single bytes, prime-sized files
- âœ… Corruption: Bit flips, burst errors, partial writes, silent corruption

### ğŸ¬ **t0200: Video Comprehensive Testing**
**Complete video production workflow coverage:**
- âœ… Formats: MP4, MOV, MXF, fragmented MP4, multi-track files
- âœ… Codecs: H.264, H.265/HEVC, ProRes, DNxHD, AAC, FLAC
- âœ… Resolutions: SD to 8K, high frame rates (120fps+)
- âœ… Keyframes: GOP alignment, scene change detection
- âœ… Proxies: Multi-resolution proxy generation (1080p, 720p, 540p)
- âœ… NLE Integration: Premiere Pro, DaVinci Resolve, After Effects workflows

### ğŸ“ **t0300: File Types Comprehensive Testing**
**20+ file formats with full fidelity:**
- âœ… Images: JPEG, PNG, TIFF, BMP, GIF, WebP, RAW (CR2, NEF), PSD, AI
- âœ… Audio: WAV, MP3, AAC, FLAC, OGG, AIFF, multichannel formats
- âœ… Video: MP4, MOV, AVI, MKV, WebM, MXF, ProRes, DNxHD
- âœ… Documents: PDF, DOC/DOCX, XLS/XLSX, PPT/PPTX, ODT, RTF
- âœ… Archives: ZIP, TAR, GZ, BZ2, 7Z, RAR, ISO
- âœ… 3D: OBJ, FBX, BLEND, ABC, USD, GLTF

### âš ï¸ **t0400: Edge Cases & Error Conditions**
**Every possible failure scenario:**
- âœ… Disk Space: Full disks, quota exceeded, sparse file handling
- âœ… Permissions: Read-only files, directory access denied, ownership
- âœ… Network: Timeouts, disconnections, partition scenarios
- âœ… Memory: Out-of-memory, address space exhaustion
- âœ… File Handles: Descriptor limits, concurrent file access
- âœ… Interruption: SIGTERM, SIGKILL, power loss simulation

### ğŸƒ **t0500: Concurrent Access & Race Conditions**
**Threading and synchronization validation:**
- âœ… Basic Concurrency: 100+ simultaneous operations
- âœ… Race Conditions: File access, chunking, repository state
- âœ… Lock Contention: Deadlock prevention, starvation avoidance
- âœ… File System: Concurrent directory operations, rename conflicts
- âœ… Memory: Cache consistency, shared data structures
- âœ… Network: Push/pull conflicts, merge synchronization

### ğŸ”’ **t0600: Data Integrity & Corruption Testing**
**Bulletproof data preservation:**
- âœ… Checksums: BLAKE3 validation, CRC verification
- âœ… Bit Corruption: Single/multiple bit flips, burst errors
- âœ… Partial Writes: Interrupted I/O, truncated files
- âœ… Silent Corruption: Memory bit flips, disk errors
- âœ… Recovery: Automatic repair, backup restoration
- âœ… Long-term: Storage media degradation simulation

### ğŸ’ª **t0700: Extreme Stress Testing**
**System limits and beyond:**
- âœ… File Sizes: 1GB, 10GB, 100GB+ individual files
- âœ… File Counts: 10k, 100k, 1M+ files in single repository
- âœ… Concurrency: 1000+ simultaneous operations
- âœ… Memory Pressure: Working sets larger than RAM
- âœ… I/O Load: Sequential/random access patterns, queue depths
- âœ… Time: Operations lasting hours, background processing

### ğŸ” **t0800: Security Testing**
**Comprehensive security validation:**
- âœ… Encryption: Key management, convergent encryption
- âœ… Authentication: Password validation, session management
- âœ… Authorization: Access control, permission enforcement
- âœ… Data Leakage: Temporary files, memory dumps, side channels
- âœ… Secure Deletion: Cryptographic erasure, overwrite patterns
- âœ… Audit Logs: Tamper-evident logging, compliance verification

### ğŸ­ **t0900: Real-World Workflow Simulations**
**Actual production scenarios:**
- âœ… NLE Workflows: Premiere, DaVinci, After Effects full pipelines
- âœ… Team Collaboration: Multi-artist projects, conflict resolution
- âœ… CI/CD Integration: Automated builds, testing, deployment
- âœ… Content Delivery: Encoding farms, distribution networks
- âœ… Backup/Recovery: Disaster scenarios, business continuity

### ğŸŒ **t1000: P2P Networking & Distributed Systems**
**Peer-to-peer and distributed operations:**
- âœ… Network Topologies: NAT traversal, firewall penetration, connection stability
- âœ… Peer Discovery: Local network, internet rendezvous, DHT, bootstrap nodes
- âœ… Distributed Sync: Conflict resolution, eventual consistency, delta sync
- âœ… Bandwidth Management: Throttling, prioritization, QoS, adaptive controls
- âœ… Security: End-to-end encryption, certificate validation, protocol versioning
- âœ… Resilience: Network partitions, offline operation, resumable transfers
- âœ… Performance: Various network conditions, latency simulation, packet loss

### ğŸ—„ï¸ **t1100: Storage Lifecycle Management**
**Data lifecycle and tier management:**
- âœ… Freeze/Thaw: Storage tier transitions, data integrity preservation
- âœ… Lifecycle Policies: Automatic age-based, access-pattern-based enforcement
- âœ… Cost Optimization: Data placement, performance vs cost tradeoffs
- âœ… Retention Policies: Regulatory compliance, legal hold, deletion controls
- âœ… Storage Quotas: Enforcement, warnings, alerts, usage tracking
- âœ… Data Aging: Archival processes, restoration, integrity verification
- âœ… Backup Integration: Disaster recovery, RTO/RPO compliance
- âœ… Regulatory: GDPR, HIPAA, SOX data lifecycle compliance

### ğŸ“‹ **t1200: Audit & Compliance Testing**
**Regulatory compliance and audit trails:**
- âœ… Audit Logging: Immutable logs, tamper detection, cryptographic signing
- âœ… Regulatory Compliance: GDPR, HIPAA, SOX, PCI-DSS requirement validation
- âœ… Data Provenance: Chain of custody, data lineage, provenance tracking
- âœ… Access Monitoring: Real-time logging, anomaly detection, alerting
- âœ… Compliance Reporting: Automated reports, third-party attestation
- âœ… Data Retention: Regulatory deletion, right to erasure, anonymization
- âœ… Cross-Border Controls: Data sovereignty, transfer authorization
- âœ… Real-Time Monitoring: Continuous compliance, violation detection

### ğŸƒ **Performance Tests (t/perf/)**
**Regression prevention and optimization:**
- âœ… Chunking Speed: 1MB/s, 100MB/s, 1GB/s+ performance targets
- âœ… Deduplication: Efficiency metrics, false positive rates
- âœ… Memory Usage: Peak consumption, memory leak detection
- âœ… I/O Patterns: Sequential vs random, read/write ratios
- âœ… Scaling: Performance vs file size, concurrency levels

### ğŸ› ï¸ **Helper Libraries**
- **lib-repo.sh**: Repository operations (init, commit, branch, merge)
- **lib-chunking.sh**: FastCDC operations (chunking, deduplication, verification)
- **lib-video.sh**: Video workflows (MP4 parsing, proxies, NLE integration)

Running Tests
-------------

### Basic Integration Tests
```bash
# Run all integration tests
just test-integration

# Run with verbose output
just test-integration-verbose

# Run in parallel (requires `prove`)
just test-integration-parallel
```

### Performance Tests
```bash
just test-performance
```

### Chainlint Validation
```bash
just test-chainlint
```

### All Tests
```bash
just test-all
```

Test Structure
--------------

Each test script follows this pattern:

```bash
#!/bin/sh

test_description='Description of what this test covers'

. ./test-lib.sh          # Load core testing functions
. ./lib-helper.sh        # Load specific helpers if needed

# Test cases
test_expect_success 'test description' '
    # Test commands here
    command1 &&
    command2 &&
    test_expectation
'

test_expect_failure 'test that should fail' '
    # Commands that should fail
'

test_done
```

Test Functions
--------------

### Core Functions
- `test_expect_success`: Test that should succeed
- `test_expect_failure`: Test that should fail
- `test_skip`: Skip a test
- `test_expect_fast`: Performance test with time limit

### Repository Helpers
- `test_create_repo`: Create test repository
- `test_repo_commit_file`: Add and commit a file
- `test_repo_file_content`: Verify file content
- `test_repo_clone`: Clone repository

### Chunking Helpers
- `test_create_chunking_file`: Create test file for chunking
- `test_verify_chunking`: Verify chunking worked
- `test_deduplication`: Test deduplication
- `test_chunking_performance`: Performance test chunking

### Video Helpers
- `test_create_minimal_mp4`: Create test MP4 file
- `test_mp4_inspect`: Test MP4 inspection
- `test_video_segment`: Test video segmentation
- `test_proxy_generate`: Test proxy generation

Writing New Tests
-----------------

1. **Choose a test number**: Use the next available tXXXX.sh or pXXXX.sh
2. **Include test-lib.sh**: Source the core library
3. **Use descriptive names**: Make test descriptions clear
4. **Keep tests focused**: One test per logical operation
5. **Use && chains**: For multi-command tests
6. **Clean up**: Tests are run in isolated directories

Example:

```bash
test_expect_success 'my new feature works' '
    # Setup
    test_create_repo test-repo &&
    cd test-repo &&

    # Test the feature
    "$DITS_BINARY" my-command arg1 arg2 &&
    test_file_exists expected-output.txt &&

    cd ..
'
```

Performance Testing
-------------------

Performance tests ensure operations meet timing requirements:

```bash
test_expect_fast "operation description" 1000 '
    # Commands to time (max 1000ms)
    "$DITS_BINARY" slow-command
'
```

Chainlint Validation
--------------------

Chainlint ensures test script quality by checking:
- Proper test structure
- No nested test functions
- Proper && chain continuations
- Valid test descriptions

Run chainlint before committing new tests:

```bash
just test-chainlint
```

Test Output
-----------

Tests support multiple output formats:

### TAP Format
```bash
GIT_TEST_TAP=1 ./run-tests.sh
```

### Verbose Output
```bash
./run-tests.sh -v
```

### Debug Output
```bash
./run-tests.sh -d
```

Parallel Execution
------------------

If `prove` is installed, tests can run in parallel:

```bash
./run-tests.sh --prove
# or
just test-integration-parallel
```

Test Environment
----------------

Tests run in isolated environments with:
- Unique temporary directories
- Clean DITS installations
- No global configuration interference
- Automatic cleanup on exit

Debugging Tests
---------------

To debug a failing test:

1. Run with verbose output: `./run-tests.sh -v -r tXXXX`
2. Check the trash directory: `ls -la t/trash.$$/`
3. Run individual test: `sh t/tXXXX.sh`
4. Add debug output: `GIT_TEST_DEBUG=1 sh t/tXXXX.sh`

When to Run Tests
-----------------

### Development Workflow
- **Basic tests** (`basic/`): Run on every code change
- **Core tests** (`core/`): Run when modifying algorithms or core features
- **QA tests** (`qa/`): Run before commits and PRs
- **Advanced tests** (`advanced/`): Run for feature integration
- **Performance tests** (`perf/`): Run weekly or for performance changes
- **Infrastructure tests** (`infra/`): Run before deployments

### CI Pipeline
```bash
# Fast feedback (every commit)
./run-tests.sh -r "basic/"

# Comprehensive validation (PR/merge)
./run-tests.sh -r "basic/ core/ qa/"

# Full release validation
./run-tests.sh
```

### Quick Test Commands
```bash
# Test just your changes
cd t && ./run-tests.sh t0000 t0001

# Test specific functionality
cd t && ./run-tests.sh -r "core/t0100"  # FastCDC
cd t && ./run-tests.sh -r "core/t0200"  # Video
cd t && ./run-tests.sh -r "qa/"         # All QA tests

# Performance regression check
cd t && ./run-tests.sh -r "perf/"
```

Contributing
------------

When adding new functionality:

1. Write integration tests in `t/`
2. Add helper functions to appropriate `lib-*.sh`
3. Run chainlint validation
4. Ensure tests pass in CI
5. Update this README if needed
